# 性能角度来看锁的产生原理 

本文写的比较闲散，主要串起来一个思考的思路
##### 性能主线来看锁的产生于原理：

---> 为了人类的生活更美好

---> 要提升任务执行效率

---> 于是我们需要并发、并行计算

---> 但是子任务（进程、线程间）在执行的时候要对共享资源进行操作
 
---> 这样数据就会出错，如脏读，覆盖写--->那么又回到出发点，既然是并发、并行引发的，我就将操作串行化，一个一个执行就不会出错啦

---> 那怎么串行化呢？

---> 站在操作系统、JVM大Boss的角度来说，我来调度你们的执行你们这些小伙子（进程、线程）从我这儿拿"许可证吧"，我给需要共享的那个资源搞个Mutex互斥量（其实也是一个简单的标识而已），同时把获取互斥量和释放互斥量的接口也都暴露给你们，这样你们可以自己玩。同一时刻你们只有一个人能操作共享资源

---> 什么你们想一定数量的多个兄弟一起访问某个资源不会引起错误？

---> 你们要求真多，那我给具体需要共享的资源搞个 Semaphore吧，信号灯亮了代表资源可以访问了。其实刚才Mutex也相当于一个二元的信号灯。同时我把点亮灯和灭灯（允许多个的话比喻减弱灯光好一些）的接口都暴露给你们，你们自己玩。同一时刻只能允许一定数量的任务（进程、线程）同时操作，其他人等待。除非有人释放了信号量，剩下的人才有机会获得信号量。

---> Mutex和Semaphore设置好以后你们兄弟之间就可以不需要我啦。你们通过这种机制就可以和谐相处了，从信息交换的角度来说也是你们兄弟之间通信的一种方式。或者说同步的方式。吃水不忘挖井人，别忘了是我提供通信方式哈。

----> 当然了，这些虽然让你们交流更灵活也能解决对共享资源的读写出错问题，但是随之而来的是性能的下降，因为你们要等待啊，并行边串行啦。从隔离级别来说就是最高的隔离级别啦。隔离你们兄弟之间对共享数据的操作。

---> 所以在用的时候你们要考虑好是否真需要（并发、并行）操作来提升性能，如果真的需要的话共享资源是否需要隔离访问。进而看看是否需要使用互斥锁和信号量。不能为了提升性能出错嘛，所以宁愿牺牲掉一部分性能哈哈。

---> 当然Mutex和Semaphore起个很形象的名字更像是一把或者多把锁。对共享资源的锁。比如变量X的锁。一单你们兄弟谁获得了这把锁等于锁上了这个资源的访问通道，你们其他人也就访问不了了。

---> BOSS:这下你们明白了吧各种锁其实就是      对并行或者并发提升性能时，当出现多进程多线程对共享资源的同时访问会造成错误时，宁愿降低性能来来避免这种错误   的一种机制。 无非是再设置一个第三方的标识，大家以哪个标识为准为信号，通过我制定的规则一个人获取后别人就不能获取到了。然后让你们兄弟自己通过我暴露的接口搞事情，但是你们按规矩就行了比如谁获得了锁一定要释放。再抽象一点 就是 “共享标识 + 既定规则办事”

---> 什么你们现在流行分布式锁？

---> 糊涂啊小伙子，那进程和线程分布在不同的机器上就不是进程和线程了嘛？ 无非是不在一个机器上嘛，那我们把刚才说的共享标识也就是我们对于共享资源虚拟设置的那个“锁” 也放到另外一个地方让他们都能访问和判断不就行了，然后大家约定好，每个线程在自己实例下该按既定规则办事还按规则办事。至于获取到锁怎么办，那就交给程序员大佬去决定吧，我们提供平台让他们天高任鸟飞。

##### 综上所述：

1.不能忘记性能这个灵魂信仰

2.各种锁，不管是单机的还是分布式的本质上是对共享资源的访问（并行并发）变 串行

3.锁的实现 ，抽象公式：“共享标识” + “既定规则办事”